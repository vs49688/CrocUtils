#include "defs.h"

/* sort faces by style, then by name, unstyled first */
int crocconvert_face_sort_proc(const void *a, const void *b)
{
    const CrocModelFace *f1 = a;
    const CrocModelFace *f2 = b;

    br_material  *mat1, *mat2;
    MaterialUser *user1, *user2;

    mat1 = crocconvert_material_find(current_croc, f1->material);
    mat2 = crocconvert_material_find(current_croc, f2->material);

    if(mat1 == mat2)
        return 0;
    else if(mat1 == NULL && mat2 != NULL)
        return -1;
    else if(mat1 != NULL && mat2 == NULL)
        return 1;

    vsc_assert(mat1 != NULL);
    vsc_assert(mat2 != NULL);

    user1 = mat1->user;
    user2 = mat2->user;

    if(!user1->is_styled && user2->is_styled) {
        return -1;
    } else if(user1->is_styled && !user2->is_styled) {
        return 1;
    } else if(user1->is_styled && user2->is_styled) {
        if(user1->style < user2->style)
            return -1;
        else if(user1->style > user2->style)
            return 1;
    }

    return strcmp(mat1->identifier, mat2->identifier);
}

static void write_obj_header(FILE *fp, size_t idx, size_t count, unsigned int num_vertices, unsigned int num_faces)
{
    fprintf(fp,
            "##\n"
            "# Generated by CrocUtils.\n"
            "#\n"
            "# Submesh:  %zu/%zu\n"
            "# Vertices: %u\n"
            "# Faces:    %u\n"
            "##\n",
            idx, count, num_vertices, num_faces);
}

static void get_mat_info(CrocModelObjMatInfo *matinfo, const CrocModelFace *face, void *user)
{
    CrocConvert  *cc;
    br_material  *mat;
    MaterialUser *matuser;

    cc = user;

    if((mat = crocconvert_material_find(cc, matinfo->matname)) == NULL)
        return;

    matuser          = mat->user;
    matinfo->matname = mat->identifier;

    if(matuser->is_styled) {
        matinfo->libname = cc->paths.materials_styled_sub1[cc->current_style];
    } else {
        matinfo->libname = cc->paths.materials_sub1;
    }
}

int crocconvert_write_model(const char *pathname, const CrocModel *mdl, size_t idx, size_t count)
{
    FILE *fp = NULL;
    int   r;

    if((r = vsc_fopen(pathname, "wb", &fp)) < 0)
        return r;

    write_obj_header(fp, idx, count, mdl->num_vertices, mdl->num_faces);

    if(croc_mod_obj_write(fp, mdl, CROC_MODEL_OBJ_WFLAG_NONE, get_mat_info, current_croc) < 0) {
        r = VSC_ERROR(errno);
        goto done;
    }

    r = 0;
done:

    if(fp != NULL)
        fclose(fp);

    return r;
}

void crocconvert_load_model_materials(CrocModel *models, size_t nmodels)
{
    /* Pass 1 - load the materials and textures. */
    for(size_t i = 0; i < nmodels; ++i) {
        CrocModel *mdl = models + i;

        for(size_t f = 0; f < mdl->num_faces; ++f) {
            const CrocModelFace *face = mdl->faces + f;

            /* Trigger BRender to load materials and textures. */
            (void)BrMaterialFind(face->material);
        }
    }

    /* Pass 2 - sort the faces. */
    for(size_t i = 0; i < nmodels; ++i) {
        CrocModel *mdl = models + i;
        qsort(mdl->faces, mdl->num_faces, sizeof(CrocModelFace), crocconvert_face_sort_proc);
    }
}

int crocconvert_load_and_convert_model(CrocConvert *cc, const char *base)
{
    CrocModel *models  = NULL;
    size_t     nmodels = 0;
    FILE      *fp      = NULL;
    int        r;
    char      *path = NULL, *outbase;

    if((outbase = vsc_strjoin("/", cc->paths.out_dir, base, NULL)) == NULL)
        return VSC_ERROR(ENOMEM);

    if((path = vsc_asprintf("%s/%s.mod", cc->paths.gdata_dir, outbase)) == NULL) {
        r = VSC_ERROR(ENOMEM);
        goto done;
    }

    if((r = vsc_fopen(path, "rb", &fp)) < 0)
        goto done;

    vsc_free(path);
    path = NULL;

    if(croc_mod_read_many(fp, &models, &nmodels, CROC_MODEL_TYPE_NORMAL) < 0) {
        r = VSC_ERROR(errno);
        goto done;
    }

    (void)fclose(fp);
    fp = NULL;

    crocconvert_load_model_materials(models, nmodels);

    /* Pass 3 - dump them. */
    for(size_t i = 0; i < nmodels; ++i) {
        const CrocModel *mdl = models + i;

        if((path = vsc_asprintf("%s_%03zu.obj", outbase, i)) == NULL) {
            r = VSC_ERROR(ENOMEM);
            goto done;
        }

        if((r = crocconvert_write_model(path, mdl, i, nmodels)) < 0)
            goto done;

        vsc_free(path);
        path = NULL;
    }

    r = 0;
done:

    if(fp != NULL)
        fclose(fp);

    if(path != NULL)
        vsc_free(path);

    if(outbase != NULL)
        vsc_free(outbase);

    if(models != NULL)
        croc_mod_free_many(models, nmodels);
    return r;
}